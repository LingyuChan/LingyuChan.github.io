/*
	JSON-to-PB
	by Matt Holt
*/
// var flage = false;
function jsonToGo(json, typename)
{
	var data;
	var scope;
	var go = "";
	var tabs = 0;

	try
	{
		data = JSON.parse(json.replace(/\.0/g, ".1")); // hack that forces floats to stay as floats
		scope = data;
	}
	catch (e)
	{
		return {
			go: "",
			error: e.message
		};
	}

	typename = format(typename || "autoGenerated");
	// 首栏 message XXX {
	// append("message "+typename+" {\n");

	parseScope(scope, typename);
	

	return { go: go };

	function parseScope(scope, scopeName){
		if (typeof scope === "object" && scope !== null){
			if (Array.isArray(scope)) { // 数组
				var sliceType, scopeLength = scope.length;

				for (var i = 0; i < scopeLength; i++)
				{
					var thisType = goType(scope[i]);
					if (!sliceType)
						sliceType = thisType;
					else if (sliceType !== thisType)
					{
						sliceType = mostSpecificPossibleGoType(thisType, sliceType);
						if (sliceType === "interface{}")
							break;
					}
				}
			
				if (sliceType === "struct") { // 数组情况
					var allFields = {};

					// for each field counts how many times appears
					for (var i = 0; i < scopeLength; i++)
					{
						var keys = Object.keys(scope[i]);
						for (var k in keys)
						{
							var keyname = keys[k];
							if (!(keyname in allFields)) {
								allFields[keyname] = {
									value: scope[i][keyname],
									count: 0
								}
							}

							allFields[keyname].count++;
						}
					}
					
					// create a common struct with all fields found in the current array
					// omitempty dict indicates if a field is optional
					var keys = Object.keys(allFields), struct = {}, omitempty = {};
					for (var k in keys) {
						var keyname = keys[k], elem = allFields[keyname];

						struct[keyname] = elem.value;
						omitempty[keyname] = elem.count !== scopeLength;
					}

					structName = parseStruct(struct, scopeName || "ArrayName" + "array", 1); // finally parse the struct !!
				}
				else if (sliceType === "slice") {
					append("optional message102 {\n");
					parseScope(scope[0], scopeName)
				}
				else
					append(" ")
			} else {
				parseStruct(scope, scopeName || "structName", 2);
			}

			return
		}
		else
			append("optional ");
			append(goType(scope));
	}

    /**
	 * 解析结构体
     * @param scope 解析的结构体对象
     * @param structName 对象名称
     * @param type 1 数组  2普通结构体 其他为空值
     * @returns {string}
     */
	function parseStruct(scope, structName, type) {

        if (structName && structName !== "")
        	append("message " + toProperCase(structName) + "{\n");

		++tabs;
		var keys = Object.keys(scope);
		for (var i in keys)
		{
			var keyname = keys[i];
			indent(tabs);
			parseScope(scope[keyname], keyname);
			j = parseInt(i) + parseInt(1);
			append(" " + format(keyname) + " = " + j);

			append(';\n');
		}
		indent(--tabs); // 添加制表符
		append("}\n");

        if (structName && structName !== "") { // 对于结构体需要添加消息
			if (structName === "autoGenerated") {
				if (type === 1){
                    append("\nmessage AutoGenerated2 {\n");
                    indent(++tabs);
                    append("repeated "+ toProperCase(structName) + " " + structName + "= 1;\n}") // 对传进来为结构体数组的json特殊处理
                }
			}else {
                indent(tabs);
                if (type === 1) {
                    append("repeated ")
                } else {
                    append("optional ")
                }
                append(toProperCase(structName)); // 在此处添加名称
			}
        }
		return keyname
	}

	function indent(tabs)
	{
		for (var i = 0; i < tabs; i++)
			go += '\t';
	}

	function append(str)
	{
		go += str;
	}

	// Sanitizes and formats a string to make an appropriate identifier in Go
	function format(str)
	{
		if (!str)
			return "";
		else if (str.match(/^\d+$/))
			str = "Num" + str;
		else if (str.charAt(0).match(/\d/))
		{
			var numbers = {'0': "Zero_", '1': "One_", '2': "Two_", '3': "Three_",
				'4': "Four_", '5': "Five_", '6': "Six_", '7': "Seven_",
				'8': "Eight_", '9': "Nine_"};
			str = numbers[str.charAt(0)] + str.substr(1);
		}
		return str //.replace(/[^a-z0-9]/ig, "") || "NAMING_FAILED";
	}

	// Determines the most appropriate Go type
	function goType(val) {
		if (val === null)
			return "{}";
		
		switch (typeof val)
		{
			case "string":
                return "string";
				// if (/\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(\+\d\d:\d\d|Z)/.test(val))
				// 	return "time.Time";
				// else
				// 	return "string";
			case "number":
				if (val % 1 === 0)
				{
					if (val > -2147483648 && val < 2147483647)
						return "int32";
					else
						return "int64";
				}
				else
					return "float64";
			case "boolean":
				return "bool";
			case "object":
				if (Array.isArray(val))
					return "slice";
				return "struct";
			default:
				return "{}";
		}
	}

	// Given two types, returns the more specific of the two
	function mostSpecificPossibleGoType(typ1, typ2) {
		if (typ1.substr(0, 5) === "float"
				&& typ2.substr(0, 3) === "int")
			return typ1;
		else if (typ1.substr(0, 3) === "int"
				&& typ2.substr(0, 5) === "float")
			return typ1;
		else
			return "{}";
	}

	// Proper cases a string according to Go conventions
	function toProperCase(str) {
		// https://github.com/golang/lint/blob/39d15d55e9777df34cdffde4f406ab27fd2e60c0/lint.go#L695-L731
		var commonInitialisms = [
			"API", "ASCII", "CPU", "CSS", "DNS", "EOF", "GUID", "HTML", "HTTP", 
			"HTTPS", "ID", "IP", "JSON", "LHS", "QPS", "RAM", "RHS", "RPC", "SLA", 
			"SMTP", "SSH", "TCP", "TLS", "TTL", "UDP", "UI", "UID", "UUID", "URI", 
			"URL", "UTF8", "VM", "XML", "XSRF", "XSS"
		];

		return str.replace(/(^|[^a-zA-Z])([a-z]+)/g, function(unused, sep, frag)
		{
			if (commonInitialisms.indexOf(frag.toUpperCase()) >= 0)
				return sep + frag.toUpperCase();
			else
				return sep + frag[0].toUpperCase() + frag.substr(1).toLowerCase();
		}).replace(/([A-Z])([a-z]+)/g, function(unused, sep, frag)
		{
			if (commonInitialisms.indexOf(sep + frag.toUpperCase()) >= 0)
				return (sep + frag).toUpperCase();
			else
				return sep + frag;
		});
	}
}

if (typeof module !== 'undefined') {
	console.log("-------------------------");
	if (!module.parent) {
        process.stdin.on('data', function(buf) {
            var json = buf.toString('utf8');
            console.log(jsonToGo(json).go)
        })
    } else {
        module.exports = jsonToGo
    }
}
